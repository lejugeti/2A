new_nt = apply(X=nt, 1, FUN=log)
new_nt = apply(X=nt, 1, FUN=log)
dim(nt)
nt = bacteries$nt
dim(nt)
nt = data.frame(bacteries$nt)
dim(nt)
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
par(c(1,2))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
par(c(1,2))
par(mfrow(c(1,2))
par(mfrow(c(1,2))
par(mfrow(c(1,2)))
help(par)
par(mfrow(1,2))
par(mfrow=c(1,2))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
plot(t, reg1$residuals)
plot(t, reg2$residuals)
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
plot(t, reg2$residuals)
abline(h=0, col='red')
plot(t, reg1$residuals)
reg1 = lm(nt~t)
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
source('H:/2A/Stats/TD/bacteries.R', echo=TRUE)
nt
colnames(nt) = "nt"
reg1 = lm(nt~t)
reg1 = lm(nt$nt~t)
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
plot(t, reg1$residuals)
abline(h=0, col='red')
plot(t, reg2$residuals)
abline(h=0, col='red')
res3$fitted
reg2$fitted
par(mfrow=c(3,1))
par(mfrow=c(3,1))
plot(t, reg2$fitted)
abline(reg2)
plot(reg2$fitted, reg2$residuals)
abline(h=0, col='red')
plot(residus_stud, ylab="res. student", ylim=c(-3.5, 3.5))
residus_stud = rstud(reg2)
plot(residus_stud, ylab="res. student", ylim=c(-3.5, 3.5))
residus_stud = rstudent(reg2)
plot(residus_stud, ylab="res. student", ylim=c(-3.5, 3.5))
abline(h=c(-2,0,2), lty=c(2,1,2))
help(rstudent)
reg1 = lm(nt$nt~t)
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
par(mfrow=c(3,1))
plot(t, reg2$fitted)
abline(reg2)
plot(reg2$fitted, reg2$residuals)
abline(h=0, col='red')
residus_stud = rstudent(reg2)
plot(residus_stud, ylab="res. student", ylim=c(-3.5, 3.5))
abline(h=c(-2,0,2), lty=c(2,1,2))
source('H:/2A/Stats/TD/bacteries.R', echo=TRUE)
beta = reg2$coefficients[1]
beta
beta = reg2$coefficients[2]
beta
help(predict)
predict(reg2, newdata=0, interval = "pred")
predict(reg2, newdata=c(0), interval = "pred")
t0 = data.frame(t=0)
predict(reg2, newdata=t0, interval = "pred")
predict(reg2, newdata=t0, interval = "pred", level=0.95)
predict(reg2, newdata=t0, interval = "pred", level=0.95)[0]
predict(reg2, newdata=t0, interval = "pred", level=0.95)[1]
n0 = predict(reg2, newdata=t0, interval = "pred", level=0.95)[1]
n0 = exp(n0)
n0
print(n0)
print("n0 = ${n0}")
sprintf("n0 = ${n0}")
str_interp("n0 = ${n0}")
library(stringr)
str_interp("n0 = ${n0}")
str_interp("n0 = ${round(n0, 3)}")
source('H:/2A/Stats/TD/bacteries.R', echo=TRUE)
reg1 = lm(nt$nt~t)
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
t
t+1
y = exp(t*reg1$coefficients[2])
line(t,y)
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
y = exp(t*reg1$coefficients[2])
line(t,y)
colnames(nt) = "nt"
reg1 = lm(nt$nt~t)
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
y = exp(t*reg1$coefficients[2])
line(t,y)
y
t*reg1$coefficients[2]
source('H:/2A/Stats/TD/bacteries.R', echo=TRUE)
x1 = runif(n, min=-5, max=5)
n = 100
x1 = runif(n, min=-5, max=5)
x2 = runif(n, min=-5, max=5)
x3 = runif(n, min=-5, max=5)
x4 = runif(n, min=-5, max=5)
x5 = runif(n, min=-5, max=5)
e = rnorm(n, 0, sigma)
sigma=2
e = rnorm(n, 0, sigma)
y = 4 - 2*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
plot(y)
matXY = data.frame(y, x1, x2, x3, x4, x5)
plot(matXY)
res = lm(y~x1+x2+x3+x4+x5)
summary(res)
res = lm(y~x1+x2+x3+x4+x5)
summary(res)
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
source('H:/2A/Stats/TD/TD2.R', encoding = 'UTF-8', echo=TRUE)
par(mfrow=c(1,2))
plot(res$fitted,res$residuals)
abline(h=0)
plot(res$fitted,y)
abline(0,1)
plot(res$fitted,y, col='r')
abline(0,1, col="r")
par(mfrow=c(1,2))
plot(res$fitted,res$residuals)
abline(h=0)
plot(res$fitted,y)
abline(0,1, col="r")
abline(0,1, col="red")
#test de la normalité de distribution des résidus
shapiro.test(res$residuals)
# Voir comment modèle se comporte avec une variable explicative en  --------
y = 4 - 0*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
res =l m(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
# Voir comment modèle se comporte avec une variable explicative en  --------
y = 4 - 0*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
res =l m(y~x1+x2+x3+x4+x5, data=matXY)
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
# Voir comment modèle se comporte avec une variable explicative en  --------
y = 4 - 0*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
n = 100
x1 = runif(n, min=-5, max=5)
x2 = runif(n, min=-5, max=5)
x3 = runif(n, min=-5, max=5)
x4 = runif(n, min=-5, max=5)
x5 = runif(n, min=-5, max=5)
sigma=2
e = rnorm(n, 0, sigma)
# Voir comment modèle se comporte avec une variable explicative en  --------
y = 4 - 0*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
#si coefficient estimé n'est pas utile car pas significatif alors on peut l'enlever
#donc création d'un nouveau modèle sans x1
res = lm(y~x2+x3+x4+x5, data=matXY)
# Voir comment modèle se comporte avec une variable explicative en  --------
y = 4 - 0*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
matXY = data.frame(y, x1, x2, x3, x4, x5)
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
#si coefficient estimé n'est pas utile car pas significatif alors on peut l'enlever
#donc création d'un nouveau modèle sans x1
res = lm(y~x2+x3+x4+x5, data=matXY)
summary(res)
# début tp régression multiple --------------------------------------------
n = 100
x1 = runif(n, min=-5, max=5)
x2 = runif(n, min=-5, max=5)
x3 = runif(n, min=-5, max=5)
x4 = runif(n, min=-5, max=5)
x5 = runif(n, min=-5, max=5)
sigma=2
e = rnorm(n, 0, sigma)
y = 4 - 2*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
matXY = data.frame(y, x1, x2, x3, x4, x5)
plot(matXY) #plot des données 2 à 2
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
par(mfrow=c(1,2))
#on regarde distribution des résidus pour voir s'il y a une structure dedans
plot(res$fitted,res$residuals)
abline(h=0)
#si bon modèle alors toutes les valeurs doivent être sur la première bisectrice
plot(res$fitted,y)
abline(0,1, col="red")
#test de la normalité de distribution des résidus
shapiro.test(res$residuals)
summary(res)
# Voir comment modèle se comporte avec une variable explicative en  --------
y = 4 - 0*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
matXY = data.frame(y, x1, x2, x3, x4, x5)
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
#si coefficient estimé n'est pas utile car pas significatif alors on peut l'enlever
#donc création d'un nouveau modèle sans x1, ce qui enlève du bruit
res = lm(y~x2+x3+x4+x5, data=matXY)
summary(res)
# début tp régression multiple --------------------------------------------
n = 100
x1 = runif(n, min=-5, max=5)
x2 = runif(n, min=-5, max=5)
x3 = runif(n, min=-5, max=5)
x4 = runif(n, min=-5, max=5)
x5 = runif(n, min=-5, max=5)
sigma=2
e = rnorm(n, 0, sigma)
y = 4 - 2*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
matXY = data.frame(y, x1, x2, x3, x4, x5)
plot(matXY) #plot des données 2 à 2
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
summary(res)
par(mfrow=c(1,2))
#on regarde distribution des résidus pour voir s'il y a une structure dedans
plot(res$fitted,res$residuals)
abline(h=0)
#si bon modèle alors toutes les valeurs doivent être sur la première bisectrice
plot(res$fitted,y)
abline(0,1, col="red")
#test de la normalité de distribution des résidus
shapiro.test(res$residuals)
source('~/2A/Stats/TD/TP1.R', echo=TRUE)
n = 1000
sigma = 3
t = 50
b1 = 3
b0 = 2
e = rnorm(n,1,sigma)
x = runif(n,0, t)
y = b1 * x + b0 + e
plot(x,y)
#abline(b0, b1, col="red")
res = lm(y~x)
summary(res)
abline(res, col="red")
#On regarde la distribution des r?sidus pour voir s'il y a normalit?
hist(res$residuals)
load(file="./data/appartements.Rda")
apt = appartements
x = apt$surface
y = apt$prix
plot(apt$surface, apt$prix)
res = lm(apt$prix~x)
summary(res)
plot(apt$surface, apt$prix)
res = lm(y~ùx)
res = lm(y~x)
summary(res)
plot(res$fitted, res$residuals)
abline(h=0, col="red")
plot(x, y)
plot(res)
summary(res)
plot(x, y)
plot(res$fitted, res$residuals)
abline(h=0, col="red")
plot(x, y)
abline(res)
abline(res, col="red")
plot(res$fitted, res$residuals)
abline(h=0, col="red")
shapiro.test(res$residuals)
hist(res$residuals)
hist(res$residuals)
n = 1000
sigma = 3
t = 50
b1 = 3
b0 = 2
e = rnorm(n,1,sigma)
x = runif(n,0, t)
y = b1 * x + b0 + e
plot(x,y)
#abline(b0, b1, col="red")
res = lm(y~x)
summary(res)
abline(res, col="red")
#On regarde la distribution des r?sidus pour voir s'il y a normalit?
hist(res$residuals)
source('~/2A/Stats/TD/etudes_data.R', encoding = 'UTF-8', echo=TRUE)
apt = appartements
x = apt$surface
y = apt$prix
plot(x, y)
abline(res, col="red")
res = lm(y~x)
new = data.frame(x=seq(20, 110, by=10))
new
inter_conf = data.frame(predict(object=res, newdata=new, interval="conf", level=0.95))
inter_conf = cbind(new, inter_conf)
inter_conf
predictions = data.frame(predict(object=res, newdata=new, interval="pred", level=0.95))
predictions = cbind(new, predictions)
predictions
inter_conf
predictions
predictions = data.frame(predict(object=res, newdata=new, interval="pred", level=0.99))
predictions = cbind(new, predictions)
inter_conf
predictions
load("./data/bacteries.Rda")
library(stringr)
nb_obs = dim(bacteries)[1]
sigma = 1
ut = rnorm(nb_obs, 0, sigma)
t = bacteries$t
nt = data.frame(bacteries$nt)
colnames(nt) = "nt"
reg1 = lm(nt$nt~t)
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
par(mfrow=c(1,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
par(mfrow=c(2,1))
plot(bacteries$t, bacteries$nt)
par(mfrow=c(1,1))
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
test = log(nt)
test
new_nt
plot(bacteries$t, bacteries$nt)
abline(reg1$coefficients[1], reg1$coefficients[2], col='red')
new_nt = apply(X=nt, 1, FUN=log)
reg2 = lm(new_nt~t)
plot(t, new_nt)
abline(reg2$coefficients[1], reg2$coefficients[2], col='red')
par(mfrow=c(3,1))
plot(t, reg2$fitted)
abline(reg2)
plot(reg2$fitted, reg2$residuals)
abline(h=0, col='red')
residus_stud = rstudent(reg2)
plot(residus_stud, ylab="res. student", ylim=c(-3.5, 3.5))
abline(h=c(-2,0,2), lty=c(2,1,2))
beta = reg2$coefficients[2]
beta
t0 = data.frame(t=0)
n0 = predict(reg2, newdata=t0, interval = "pred", level=0.95)[1]
n0 = exp(n0)
n0 = predict(reg2, newdata=t0, interval = "pred", level=0.95)[1]
n0
n0 = exp(n0)
str_interp("n0 = ${round(n0, 3)}")
plot(bacteries$t, bacteries$nt)
par(mfrow=c(1,1))
plot(bacteries$t, bacteries$nt)
# ajout / retrait de variables du modèle ----------------------------------
n = 100
x1 = runif(n, min=-5, max=5)
x2 = runif(n, min=-5, max=5)
x3 = runif(n, min=-5, max=5)
x4 = runif(n, min=-5, max=5)
x5 = runif(n, min=-5, max=5)
sigma=2
e = rnorm(n, 0, sigma)
y = 4 - 2*x1 + 3 * x2 - 5*x3 + 0.8*x4 + 1.4*x5 + e
matXY = data.frame(y, x1, x2, x3, x4, x5)
res = lm(y~x1+x2+x3+x4+x5, data=matXY)
drop1(res)
res2 = lm(y~x1+x2, data=matXY)
add1(res, ~x1+x2+x3+x4+x5)
add1(res2, ~x1+x2+x3+x4+x5)
res = lm(y~x1, data=matXY)
step(res, ~x1+x2+x3+x4+x5)
# la fonction cherche pas à pas quelle est la meilleure variable à ajouter au modèle
# les variables sont classées en fonction du critère AIC en ascendant
res = lm(y~, data=matXY)
# la fonction cherche pas à pas quelle est la meilleure variable à ajouter au modèle
# les variables sont classées en fonction du critère AIC en ascendant
res = lm(y, data=matXY)
x1
# la fonction cherche pas à pas quelle est la meilleure variable à ajouter au modèle
# les variables sont classées en fonction du critère AIC en ascendant
res = lm(y~x1, data=matXY)
step(res, ~x1+x2+x3+x4+x5)
# la fonction cherche pas à pas quelle est la meilleure variable à ajouter au modèle
# les variables sont classées en fonction du critère AIC en ascendant
res = lm(y~x3, data=matXY)
step(res, ~x1+x2+x3+x4+x5)
load(file = "./data/lampes.Rda")
load(file = "./data/lampes.Rda")
lampes
plot(lampes$duree~lampes$procede)
res = lm(duree~procede, data=lampes)
summary(res)
help(groupby)
help("groupby")
help("group_by")
help("group.by")
mean(lampes)
apply(lampes, mean)
apply(lampes, mean(x))
apply(lampes, FUN=mean(x))
apply(X=lampes, FUN=mean(x))
apply(X=lampes$duree, FUN=mean(x))
apply(X=lampes$duree, FUN=mean())
apply(X=lampes$duree, FUN=mean(duree))
apply(X=lampes$duree, FUN=mean(lampes$duree))
apply(X=lampes$duree, FUN=mean)
View(lampes)
dim(lampes$duree)
lampes$duree
apply(X=lampes, FUN=mean)
apply(X=lampes, MARGIN=1 FUN=mean)
apply(X=lampes, MARGIN=1, FUN=mean)
apply(X=lampes, MARGIN=2, FUN=mean)
View(lampes)
dim(lampes)
apply(X=lampes$duree, MARGIN=2, FUN=mean)
apply(X=lampes$duree, MARGIN=1, FUN=mean)
apply(X=lampes, MARGIN=1, FUN=mean)
apply(X=lampes, MARGIN=2, FUN=sum)
anova(res)
df = load("data/plaques.Rda")
View(plaques)
plot(rugosite~duree, data=df)
plot(rugosite~duree, data=df)
plot(df$rugosite~df$duree)
df
plot(rugosite~duree, plaques)
res = lm(duree~rugosite, data=plaques)
res = lm(rugosite~duree, data=plaques)
anova(res)
rendement<-c(15,14,17,18,17,18,12,13,12,14,15,15,
16,19,18,23,24,25,15,14,14,12,11,10,
18,17,17,20,21,21,17,19,17,12,13,12)
plant<-as.factor(rep(rep(c("Plant I","Plant II","Plant III","Plant IV"),each=3),3))
engrais<-as.factor(rep(c("Engrais A","Engrais B","Engrais C"),each=12))
donnees<-data.frame(rendement,plant,engrais)
levels(engrais) # donne les differents niveaux du facteur "engrais"
levels(plant) # donne les differents niveaux du facteur "plant"
table(engrais) # indique les nombres d’observations par niveau du facteur "engrais"
table(plant) # indique les nombres d’observations par niveau du facteur "plant"
boxplot(rendement~engrais*plant)
boxplot(rendement~plant)
boxplot(rendement~engrais)
interaction.plot(plant,engrais,rendement)
interaction.plot(plant,engrais,rendement)
interaction.plot(engrais,plant,rendement)
interaction.plot(plant,engrais,rendement)
table(plant~engrais)
table(plant,engrais)
tapply(rendement,list(engrais,plant),mean)
res.aov <- aov(rendement~engrais*plant) # modele avec interaction
summary(res.aov)
res<-lm(rendement~engrais*plant) # calage sur la case "Type I" et "Engrais A"
summary(res)
